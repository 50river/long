<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>iPhone背面カメラ対応 自動キャプチャ＆パノラマ撮影アプリ（デバッグ付き）</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    video, canvas { max-width: 100%; border: 1px solid #ccc; }
    button { margin: 5px; padding: 10px 15px; }
  </style>
</head>
<body>
  <h1>iPhone背面カメラ対応 自動キャプチャ＆パノラマ撮影アプリ</h1>
  
  <video id="video" autoplay playsinline></video>
  <br>
  <button id="startBtn">自動キャプチャ開始</button>
  <button id="stopBtn" disabled>自動キャプチャ停止</button>
  <button id="stitchBtn" disabled>パノラマ生成</button>
  <p id="status">キャプチャ枚数: 0</p>
  
  <canvas id="resultCanvas" width="640" height="480"></canvas>
  <canvas id="hiddenCanvas" width="640" height="480" style="display: none;"></canvas>
  
  <script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stitchBtn = document.getElementById('stitchBtn');
    const status = document.getElementById('status');
    const resultCanvas = document.getElementById('resultCanvas');
    const resultCtx = resultCanvas.getContext('2d');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const hiddenCtx = hiddenCanvas.getContext('2d');

    let capturedImages = [];
    let capturing = false;
    let previousImageData = null;
    let lastCaptureTime = 0;
    const captureCooldown = 1000; // 1秒クールダウン
    const diffThreshold = 30;   // 画素差の閾値（必要に応じて調整）

    // 初回はデフォルトカメラでアクセス許可取得し、その後背面カメラに切り替える
    function initCamera() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          video.srcObject = stream;
          return navigator.mediaDevices.enumerateDevices();
        })
        .then(devices => {
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          const backCamera = videoDevices.find(device => /back|rear|環境/i.test(device.label));
          if (backCamera) {
            const constraints = {
              video: {
                deviceId: { exact: backCamera.deviceId },
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            };
            return navigator.mediaDevices.getUserMedia(constraints);
          } else {
            return Promise.reject("背面カメラが見つかりませんでした。");
          }
        })
        .then(stream => {
          video.srcObject = stream;
          console.log("背面カメラに切り替えました");
        })
        .catch(err => {
          console.error("カメラ設定エラー:", err);
        });
    }
    
    initCamera();

    // 2つの ImageData の平均差を計算
    function computeDifference(data1, data2) {
      let diff = 0;
      const len = data1.data.length;
      const step = 4 * 10; // 10ピクセル間隔でサンプリング
      let count = 0;
      for (let i = 0; i < len; i += step) {
        diff += Math.abs(data1.data[i]   - data2.data[i]) +
                Math.abs(data1.data[i+1] - data2.data[i+1]) +
                Math.abs(data1.data[i+2] - data2.data[i+2]);
        count++;
      }
      return diff / (3 * count);
    }

    // フレーム処理
    function processFrame() {
      if (!capturing) return;
      hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
      const currentImageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
      if (previousImageData) {
        const diff = computeDifference(previousImageData, currentImageData);
        console.log("diff:", diff);
        const now = Date.now();
        if (diff > diffThreshold && (now - lastCaptureTime > captureCooldown)) {
          console.log("キャプチャ実行。diff:", diff, "経過時間:", now - lastCaptureTime);
          const dataURL = hiddenCanvas.toDataURL('image/png');
          capturedImages.push(dataURL);
          lastCaptureTime = now;
          status.textContent = "キャプチャ枚数: " + capturedImages.length;
        }
      }
      previousImageData = currentImageData;
      requestAnimationFrame(processFrame);
    }

    startBtn.addEventListener('click', () => {
      capturing = true;
      previousImageData = null;
      capturedImages = [];
      lastCaptureTime = 0;
      status.textContent = "キャプチャ枚数: 0";
      startBtn.disabled = true;
      stopBtn.disabled = false;
      stitchBtn.disabled = true;
      processFrame();
      console.log("自動キャプチャ開始");
    });

    stopBtn.addEventListener('click', () => {
      capturing = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (capturedImages.length > 0) {
        stitchBtn.disabled = false;
      }
      console.log("自動キャプチャ停止");
    });

    stitchBtn.addEventListener('click', () => {
      if (capturedImages.length < 2) {
        alert("パノラマ生成には2枚以上の画像が必要です。");
        return;
      }
      const singleWidth = hiddenCanvas.width;
      const height = hiddenCanvas.height;
      const panoramaCanvas = document.createElement('canvas');
      panoramaCanvas.width = singleWidth * capturedImages.length;
      panoramaCanvas.height = height;
      const panoCtx = panoramaCanvas.getContext('2d');

      let loadedImages = [];
      let imagesLoaded = 0;
      capturedImages.forEach((dataURL, index) => {
        let img = new Image();
        img.src = dataURL;
        img.onload = () => {
          loadedImages[index] = img;
          imagesLoaded++;
          if (imagesLoaded === capturedImages.length) {
            loadedImages.forEach((img, i) => {
              panoCtx.drawImage(img, i * singleWidth, 0, singleWidth, height);
            });
            resultCanvas.width = panoramaCanvas.width;
            resultCanvas.height = height;
            resultCtx.drawImage(panoramaCanvas, 0, 0);
            console.log("パノラマ生成完了");
          }
        };
      });
    });
  </script>
</body>
</html>
