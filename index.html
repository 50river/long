<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>iPhone背面カメラ対応 自動キャプチャ＆パノラマ撮影アプリ</title>
  <!-- OpenCV.js は必要に応じて読み込みます（今回の実装では利用していませんが、透視変換など拡張時に利用可能） -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    video, canvas { max-width: 100%; border: 1px solid #ccc; }
    button { margin: 5px; padding: 10px 15px; }
  </style>
</head>
<body>
  <h1>iPhone背面カメラ対応 自動キャプチャ＆パノラマ撮影アプリ</h1>
  
  <!-- カメラ映像表示 -->
  <video id="video" autoplay playsinline></video>
  <br>
  <!-- 操作用ボタン -->
  <button id="startBtn">自動キャプチャ開始</button>
  <button id="stopBtn" disabled>自動キャプチャ停止</button>
  <button id="stitchBtn" disabled>パノラマ生成</button>
  <p id="status">キャプチャ枚数: 0</p>
  
  <!-- 結果表示用キャンバス -->
  <canvas id="resultCanvas" width="640" height="480"></canvas>
  
  <!-- 隠しキャンバス（映像解析用） -->
  <canvas id="hiddenCanvas" width="640" height="480" style="display: none;"></canvas>
  
  <script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stitchBtn = document.getElementById('stitchBtn');
    const status = document.getElementById('status');
    const resultCanvas = document.getElementById('resultCanvas');
    const resultCtx = resultCanvas.getContext('2d');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const hiddenCtx = hiddenCanvas.getContext('2d');

    // 撮影した画像（DataURL形式）を保持する配列
    let capturedImages = [];
    let capturing = false;
    let previousImageData = null;
    let lastCaptureTime = 0;
    const captureCooldown = 1000; // キャプチャ間のクールダウン（1秒）
    const diffThreshold = 30;   // 画素差の閾値（適宜調整）

    // カメラストリーム取得：初回はデフォルトカメラでアクセス許可を得た後、背面カメラに切り替え
    function initCamera() {
      // 初回はデフォルトカメラでアクセス許可を取得
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          video.srcObject = stream;
          // アクセス許可後、デバイス一覧を取得
          return navigator.mediaDevices.enumerateDevices();
        })
        .then(devices => {
          // videoinput のデバイスのみ抽出
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          // ラベルに "back", "rear", "環境" などが含まれるデバイスを背面カメラとして選択
          const backCamera = videoDevices.find(device => /back|rear|環境/i.test(device.label));
          if (backCamera) {
            const constraints = {
              video: {
                deviceId: { exact: backCamera.deviceId },
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            };
            return navigator.mediaDevices.getUserMedia(constraints);
          } else {
            return Promise.reject("背面カメラが見つかりませんでした。");
          }
        })
        .then(stream => {
          // 背面カメラのストリームを video 要素に設定
          video.srcObject = stream;
        })
        .catch(err => {
          console.error("カメラ設定エラー:", err);
        });
    }
    
    // 初期化実行
    initCamera();

    // 2つの ImageData 間の平均差を計算（計算負荷軽減のため、10ピクセルごとにサンプリング）
    function computeDifference(data1, data2) {
      let diff = 0;
      const len = data1.data.length;
      const step = 4 * 10; // RGBA の 4要素 × 10ピクセル間隔
      let count = 0;
      for (let i = 0; i < len; i += step) {
        diff += Math.abs(data1.data[i]   - data2.data[i]) +
                Math.abs(data1.data[i+1] - data2.data[i+1]) +
                Math.abs(data1.data[i+2] - data2.data[i+2]);
        count++;
      }
      return diff / (3 * count);
    }

    // 各フレームを解析し、差分が閾値を超えた場合にキャプチャする処理
    function processFrame() {
      if (!capturing) return;
      hiddenCtx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
      const currentImageData = hiddenCtx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
      if (previousImageData) {
        const diff = computeDifference(previousImageData, currentImageData);
        const now = Date.now();
        if (diff > diffThreshold && (now - lastCaptureTime > captureCooldown)) {
          const dataURL = hiddenCanvas.toDataURL('image/png');
          capturedImages.push(dataURL);
          lastCaptureTime = now;
          status.textContent = "キャプチャ枚数: " + capturedImages.length;
        }
      }
      previousImageData = currentImageData;
      requestAnimationFrame(processFrame);
    }

    // 自動キャプチャ開始
    startBtn.addEventListener('click', () => {
      capturing = true;
      previousImageData = null;
      capturedImages = [];
      lastCaptureTime = 0;
      status.textContent = "キャプチャ枚数: 0";
      startBtn.disabled = true;
      stopBtn.disabled = false;
      stitchBtn.disabled = true;
      processFrame();
    });

    // 自動キャプチャ停止
    stopBtn.addEventListener('click', () => {
      capturing = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (capturedImages.length > 0) {
        stitchBtn.disabled = false;
      }
    });

    // 撮影済み画像を横に連結し、パノラマ画像を生成する処理（単純連結）
    stitchBtn.addEventListener('click', () => {
      if (capturedImages.length < 2) {
        alert("パノラマ生成には2枚以上の画像が必要です。");
        return;
      }
      const singleWidth = hiddenCanvas.width;
      const height = hiddenCanvas.height;
      const panoramaCanvas = document.createElement('canvas');
      panoramaCanvas.width = singleWidth * capturedImages.length;
      panoramaCanvas.height = height;
      const panoCtx = panoramaCanvas.getContext('2d');

      let loadedImages = [];
      let imagesLoaded = 0;
      capturedImages.forEach((dataURL, index) => {
        let img = new Image();
        img.src = dataURL;
        img.onload = () => {
          loadedImages[index] = img;
          imagesLoaded++;
          if (imagesLoaded === capturedImages.length) {
            loadedImages.forEach((img, i) => {
              panoCtx.drawImage(img, i * singleWidth, 0, singleWidth, height);
            });
            resultCanvas.width = panoramaCanvas.width;
            resultCanvas.height = height;
            resultCtx.drawImage(panoramaCanvas, 0, 0);
          }
        };
      });
    });
  </script>
</body>
</html>
